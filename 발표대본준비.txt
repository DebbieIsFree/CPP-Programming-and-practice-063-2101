
 
------------------------------------------------------------------------------------------------------
<1> 인트로 :  전체 흐름 소개 

안녕하세요 저희는 은행관리시스템을 개발한 변재용, 이지윤, 전창우, 장지원으로 구성된 BankBank팀입니다.
시작하기에 앞서 저희 프로그램의 전체적인 흐름을 간략하게 소개해드리겠습니다.
저희 BankBank팀은 C++ 수업에서 배운 내용을 팀프로젝트에 최대한 적용하고, C++ 프로그래밍(개념)을 이해하는데 
관리시스템을 만드는 것이 적합하다고 생각하여 은행관리시스템을 만들었습니다.

은행에 가면 계좌 생성, 계좌 해지, 적금, 대출 등을 할 수 있습니다. 
그래서 이러한 기능들을 Bank라는 핸들러 클래스에서 종합적으로 관리할 수 있도록 
크게 계좌(Account), 적금(Saving), 대출(Loan)을 개별 클래스로 구현했습니다.
또한 이 3개의 기능을 구현하는데 필요한
 AccounDB클래스를 비롯한 각종 데이터베이스(DB) 클래스와 Catalogue클래스 그리고 LoanPersonInfo,  SavingItem 등의 클래스를 
추가적으로 만들어 데이터의 저장과 확인을 통해 계좌, 대출, 적금과 관련된 여러 기능을 이용할 수 있도록 만들었습니다.  

/*
고객과 관리자가 생성하는 데이터만 따로 저장하기 위해
 AccountDB는 Account 클래스의 객체들을 벡터로 저장하고,  
 적금 계좌 정보를 저장하는 SavingAccount 클래스의 데이터를 벡터 형태로 저장하는 SavingAccountDB를 만들었습니다
 또한 SavingItem에는 적금 상품 정보를 저장할 수 있고 이 클래스의 객체를 SavingItemCatalogue에서 벡터 형태로 
저장할 수 있게 하였습니다.
*/

저희는 팀 프로젝트의 의미가 협업과 분업에 있다 생각하여 팀 조원 한명당 크게 하나의 기능을(클래스를) 담당하였습니다.
각 기능을 구현하는데 필요한 클래스와 그 클래스에 필요한 추가적인 클래스, 헤더파일, 소스파일 등도 각자 맡은 기능을
고려해 작성하였고 어려운 부분은 함께 협동하여 해결하였습니다. 

이제 각 클래스의 코드를 보며 구체적으로 소개해드리겠습니다.
-------------------------------------------------------------------------------------------------------
 <2> 본론 - (1) 각 클래스 설명 

Bank 클래스 (핸들러 클래스)

/*
은행에서 할 수 있는 일은 크게 계좌 생성 및 해지, 적금 상품 조회 및 신청, 대출 상품 조회 및 신청 등이 있습니다.
이러한 기능을 각 개별 클래스로 만들어 Bank라는 핸들러 클래스에서 ....
*/

--------------
Account 클래스 
이 클래스를 만든 이유는 고객이 계좌를 생성하거나 해지할 때 필요한 계좌번호, 잔액, 고객명 등의 정보를 담기위함입니다. 
이 클래스의 멤버변수로 accID(계좌번호), balance(통장잔액), password(비밀번호), cusName(고객명)이 있습니다.
처음에 이 클래스를 구현할 때, 생성자에 accID(계좌번호)와 password(비밀번호)까지 같이 인자로 전달해 초기화시켰습니다.
하지만 실질적으로 은행에서 계좌를 생성할 때 계좌번호는 고객이 생성하는 것이 아니라 은행에서 자체적으로 생성해
고객에게 랜덤으로 제공합니다. 그래서 srand와 time 함수를 통해 계좌번호를 랜덤생성하여 초기화시켰습니다.
또한 은행은 고객의 정보를 알고있되, 외부로 노출시키면 안되므로 보안유지를 위해 고객이 비밀번호를 입력시 콘솔창에는 *(애스테리크)로
출력되도록 하였습니다. 이를 위해 _kbhit() 함수로 키보드를 통한 입력 유무를 확인해 bool 값을 리턴하고, true 값이 반환되었다면  
 char형 임시 배열 a[10]에 _getch() 함수로 입력받은 값을 저장한 뒤 cout으로 *(애스테리크)를 출력하였습니다.
또한 for문과 static_cast 형 변환 연산자를 이용하여 char형 임시 배열 a에 있는 값을 int형으로 바꾼 뒤 Account 클래스의 비밀번호로
저장하였습니다. 
이러한 과정을 통해 계좌와 관련된 고객 정보를 Account 클래스에 저장하였습니다. Account 클래스의 객체에 저장된
고객의 정보를 얻기 위해 멤버함수로 GetAccID(), GetName(), GetPassWord() 등을 정의하였습니다.

계좌 생성시 생성자로 통장 잔액을 초기화시켰지만, 추후 고객이 추가적으로 돈을 입금할 수 있으므로 
Deposit() 함수를 생성하였습니다. 
돈을 입금할 수 있다면 출금할 수도 있어야 합니다. 이는 멤버함수인 Withdraw()로 가능하고, 이 함수 또한 비밀번호 보안유지를 
위한 코드를 사용합니다.

----------------
AccountDB 클래스 

은행에 고객이 한 명만 있지 않습니다. 많은 고객의 계좌를 관리하기 위해서는 데이터베이스(DB) 시스템을 구축해야 합니다.
그 기능을 하는 것이 바로 AccountDB 클래스입니다.
 객체 배열이나 객체 포인터 배열이 아닌, C++ 표준 라이브러리에 정의된 벡터<vector> 컨테이너를 활용해
Account 객체를 연속적으로 저장할 수 있게 구현했습니다. 
STL vector는 데이터 개수의 가변성과 원소의 추가 및 삭제의 편리함을 고려하여 사용되었습니다.
한 개의 Account 객체를 생성하더라도 이는 AccoutDB 클래스 안의 벡터 컨테이너에 저장되어야 하므로
결국 계좌 생성 및 해지, 입금 및 출금, 계좌 정보 인출은  AccountDB 클래스의 멤버함수로 다시 정의돼, Account 클래스의
멤버함수를 호출하여 씁니다. 
 
- addAccount()
 고객이 입력한 정보로 Account 객체를 초기화시킨 뒤, 데이터베이스(DB)에 넣는 함수입니다.
DB가 vector로 구성되었기 때문에 DB.size(), DB.push_back()와 같은 vector 함수를 사용했습니다.

이 외에도 AccountDB에 멤버함수를 재정의해 Account 클래스의 멤버함수를 호출함으로써
 계좌 해지, 입금, 출금, 계좌 조회 등을 할 수 있도록 했습니다.

-----------------
LoanItem 클래스

 은행에는 대출 상품이 다양하게 있습니다. 예를들어, A라는 상품은 연금리 4%에 상환방식은 원금균등상환이고,
B라는 상품은 연금리는 10.3%에 상환 방식은 만기일시상환입니다. 이처럼 여러 개의 대출 상품을
만들기 위해 LoanItem이라는 클래스를 만들었습니다. 
클래스의 멤버함수로 연금리(LoanRate),  대출최대한도금액(LoanLimit), 대출기간(Period), 대출금 상환방법(PayBackWay) 을
설정하였습니다. 대출 상품은 은행에서 만들어 고객에게 제공하는 것으로 고정적이라 할 수 있습니다. 그래서 
생성자로 초기화시켰습니다. 

특정 대출 상품이 궁금할 땐  LoanItemInfo() 함수로 번호를 입력해 확인할 수 있으며,
getLoanRate(), getPeriod(), getPayBackWay() 함수로 대출 상품의 각 정보를 리턴(return)해 대출 과정에 
사용될 수 있도록 하였습니다. 

-----------------
LoanPersonInfo 클래스 

Account (계좌) 클래스와 마찬가지로 대출하는 고객이 한 명만 있지 않습니다. 많은 대출 고객의 정보를 
저장하기 위해서는 각각의 고객 정보를 담는 클래스를 따로 만들어야 합니다. 그래서 LoanPersonInfo 클래스를 
만들었고 이러한 데이터(객체)를 관리할 수 있는 일종의 데이터베이스 개념으로 LoanPersonInfoDB 클래스도 만들었습니다.

LoanPersonInfo 클래스는 계좌번호(accID), 대출희망금액(desired_amount), 대출상품번호(loanNum), 상환액수(payback)를 
멤버변수로 가지고 있습니다. 

LoanPersonInfo 객체 생성 시, 고객의 대출 상환액이 없으므로 payback은 '0'으로 초기화시킵니다.
이 외에 다른 정보는 입력받은 값으로 초기화시킵니다.

LoanItem 클래스와 마찬가지로 getAccId(), getLoanNum(), getLoanDesiredAmount(), getLoanPayBack() 멤버함수를 
정의해 대출하는 고객의 정보를 리턴(return)하였습니다. 반환된 정보는 대출하는 과정에 사용되었습니다.

-------------------
LoanPersonInfoDB 클래스 

이 클래스는 대출한 고객 정보를 담고 있는 LoanPersonInfo 객체를 효율적으로 관리하기 위해 만들어졌습니다.
Account 객체를 관리하는 AccountDB 클래스와 마찬가지로 이 클래스 또한 STL vector 컨테이너로 LoanPersonInfo 객체를 
선형적으로 저장하였습니다. "연속된 공간에 순차적으로 같은 자료형의 데이터를 저장한다"는 측면에서 배열과 같지만
vector 컨테이너가 좀 더 유연성과 편리함을 갖췄다고 생각해 사용하였습니다.

LoanPersonInfo과 LoanPersonInfoDB 클래스의 관계는 Account와 AccountDB 클래스의 관계와 같습니다.
이 둘 다 각 특성에 맞는 데이터 저장 형태를 클래스로 만들고, 그것들을 관리하는 클래스를 다시 만든 것입니다.

대출한 고객이 한 명이든 백 명이든, LoanPersonInfo 객체로 생성된 모든 대출 고객의 정보는 LoanPersonInfoDB에 
벡터 형태로 저장됩니다. 그렇기에 LoanPersonInfoDB 클래스에 '대출 고객 추가(addLoanPersonInfo)', '고객의 대출 상품 조회(getLoanNumber)', 
'대출한 고객의 계좌 조회(getLoanAccID)', '고객의 대출금 조회(getLoanAmount)'를 할 수 있는 함수를 정의하였고, 그 안에서 다시 LoanPersonInfo 객체의
멤버함수를 호출하는 형태를 갖습니다.

또한 vector의 특징이 '원소 개수의 가변성'이므로 vector에 저장된 원소 갯수를  리턴(return)하는 getSize()함수를 
벡터함수 .size()를 이용해 정의하였습니다.

이렇게 리턴(return)된 값들 또한 대출 과정에서 사용됩니다.

--------------------
Loan 클래스 (총괄 - 핸들러 클래스)


--------------------
SavingAccount 클래스   &  SavingAccountDB 클래스

저희 팀은 Account(계좌)와 SavingAccount(적금계좌)를 구분하여 만들었습니다.
왜냐하면 적금(Saving)은 예금상품의 하나로 일정 기간 동안 일정 또는 비일정 금액을 넣어 
만기일에 이자와 함께 돌려받기 때문입니다.

그래서 생성자 SavingAccount()로 값을 초기화할 때 입금은 Account 생성자로, 적금은 SavingAccount 생성자 이니셜라이저로
구분하였습니다.

은행 관리자 입장에서,  적금 상품을 이용한 고객의 정보를 얻기 위해  GetRate(), GetSavingMoney(), GetSavingData() 멤버함수를 
정의하였고, 적금 고객의 정보를 조회하기 위해 ShowSavingAccountInfo() 함수를 정의하였습니다.

SavingAccount 객체를 관리하기 위해 SavingAccountDB에서 SavingAccount형 vector를 만들었습니다.

sortSavingAccount(), searchSavingAccount()를 제외한 SavingAccountDB 클래스의 다른 멤버함수들은 
SavingAccountDB클래스에서 SavingAccoun 객체의 멤버함수를 호출하여 고객의 정보를 리턴하는 함수를 가진다는 점에서
 Account & AccountDB 클래스와   LoanIPersonInfo & LoanPersonInfoDB 클래스와 같습니다. 



C++ STL 에서 제공하는 알고리즘 중에 sort 알고리즘을 사용하기 위해 <argorithm> 헤더파일을 include하였습니다.
 compareFunction() 함수를 이용한 오름차순 정렬 방식을 사용하였고, 이를 위해 sortSavingAccount() 함수를 만들었습니다. 
compareFunction()에서 오름차순으로 정렬할 수 있게 bool 값을 return하였고, 이 값을 sortSavingAccount() 함수의 3번째 인자로
줘 최종적으로 오름차순으로 정렬하였습니다.


또한 searchSavingAccount()는 기존의 선형탐색에서 이진탐색으로 바꿔 좀 더 효율적으로 개선하였고 
이 함수는 적금 데이터베이스(SavingAccountDB) 저장된 고객의 계좌번호와 입력된 계좌번호가 같으면 
(SavingAccount)DB에 저장된 원소의 인덱스 값을 반환합니다.

--------------------
SavingItem 클래스  &  SavingCatalogue 클래스 

SavingItem 클래스와  SavingCatalogue 클래스의 관계는 앞에서 설명한 클래스와 그 객체를 저장하는 일종의 데이터베이스(DB)
개념의 DB클래스와 같습니다.

이 클래스는 은행의 다양한 적금 상품을 구현하기 위한 클래스로 이자율(Rate), 적금 가능 최대 금액(savingMoneyRate), 
적금 개월수(savingDate)를 멤버변수로 갖습니다.

적금 상품은 은행이 만들어 고객에게 제공하는 것으로 고정적이라 볼 수 있습니다. 그래서 은행 입장에서 생각하여
생성자를 통해 바로 초기화하였습니다.

아까 말씀드렸던 것처럼 적금 상품은 은행에서 만드는데요, 그렇기에 은행에서 적금 상품의 일부 내용을 
변경할 수도 있습니다. 은행 입장에서 적금 상품의 이자율(Rate)이나 적금 개월수(savingDate) 등을 변경할 수 있도록
setRate(), setDate(), setMoneyRate() 함수를 만들었습니다.

또한 적금 상품의 이자율(Rate)이나 적금 개월수(savingDate)와 같은 정보가 궁금할 때 확인할 수 있도록
getRate(), getMoneyRate(), getDate() 함수를 만들었습니다. 이는 SavingItem (객체를)을 관리하는 SavingItemCatalogue에서 호출하는
방식으로 사용됩니다.

특정 적금 상품이 궁금할 때는 상품번호를 입력하여 조회할 수 있도록 getSavingItemInfo 함수를 만들었습니다.

은행의 적금 상품은 여러 개 존재하므로 이를 관리할 수 있도록
 SavingItemCatalogue 클래스에 vector를 사용하였습니다. 

setSavingItmeCatalogue()함수는 은행이 새로운 적금 상품을 만들 경우를 생각하여 구현한 것입니다.

changeSavingItemCatalogue() 함수는 기존의 적금 상품의 내용을 변경하기 위해 만든 것으로
SavingItem 객체의 멤버함수를 호출하는 방식을 사용합니다.

그외 적금 상품 정보를 반환하는 여러 get~()함수와 개별 및 전체 적금 상품 조회 함수들은 
SavingItem 객체의 멤버함수를 호출하는 방식입니다.


-------------------
Saving 클래스 (총괄 - 핸들러 클래스)

 
------------------------------------------------------------------------------------------------------
 2) 본론 -  (1) 실제 은행 시스템을 고려해 보완한 부분

  ex) 

- 메뉴 구성시 뒤로 가기 기능 추가

- 계좌 생성시 - 계좌 번호 random 생성

- 비밀번호 입력시 보안유지 

- 고객페이지, 관리페이지 구분   <관리 페이지 --> 비밀번호 1개 설정>  


------------------------------------------------------------------------------------------------------
 2) 본론 -  (2) 아쉬운 부분 & 보완할 점 

  ex) 

/*
-  탐색기법  (탐색의 효율성)
*/


- 프로그램 동작에 초점을 두다보니 오류(error)가 발생하는 기능을(코드를) 삭제했습니다.
 그러다 보니 실제 은행에서 이뤄지는 절차를 세부적으로 담지 못하여 아쉬웠습니다.   

- 디자인 측면 (시각적인 부분)

- 그 외

------------------------------------------------------------------------------------------------------
3) 결론 - (1) 배운 점

  ex) 
 
각 조원들이 구현한 코드를 합치는 과정에서 생각보다 오류가 많았지만 이를 해결하면서
개인이 아닌 팀으로서 프로그램을 만드는 과정을 배울 수 있었습니다.

